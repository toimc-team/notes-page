(window.webpackJsonp=window.webpackJsonp||[]).push([[170],{1139:function(v,_,e){"use strict";e.r(_);var t=e(11),a=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"vue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[v._v("#")]),v._v(" Vue")]),v._v(" "),_("h2",{attrs:{id:"_1-vue数据劫持-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue数据劫持-中级"}},[v._v("#")]),v._v(" 1. vue数据劫持（中级）")]),v._v(" "),_("p",[_("strong",[v._v("数据劫持：")]),v._v(" vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过"),_("code",[v._v("Object.defineProperty()")]),v._v("来劫持各个属性的"),_("code",[v._v("setter")]),v._v(","),_("code",[v._v("getter")]),v._v(",在数据变动时发布消息给订阅者，触发相应的监听回调。")]),v._v(" "),_("h2",{attrs:{id:"_2-阐述一下你所理解的mvvm响应式原理-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-阐述一下你所理解的mvvm响应式原理-中级"}},[v._v("#")]),v._v(" 2. 阐述一下你所理解的MVVM响应式原理（中级）")]),v._v(" "),_("p",[v._v("vue 是采用数据劫持配合发布者-订阅者的模式的方式，通过"),_("code",[v._v("Object.defineProperty()")]),v._v("来劫持各个属性的 getter 和 setter，在数据变动时，发布消息给依赖收集器( dep 中的subs)，去通知(notify)观察者，做出对应的回调函数，去更新视图。")]),v._v(" "),_("p",[v._v("MVVM 作为绑定的入口，整合 Observer,Compile 和 Watcher 三者，通过 Observer 来监听 model 数据变化，通过 Compile 来解析编译模板指令，最终利用Watcher 搭起 Observer，Compile 之间的通信桥路，达到数据变化=>视图更新；视图交互变化=>数据 model 变更的双向绑定效果。")]),v._v(" "),_("h2",{attrs:{id:"_3-说说vue的生命周期-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-说说vue的生命周期-中级"}},[v._v("#")]),v._v(" 3. 说说vue的生命周期（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("beforeCreate")]),v._v(" "),_("ul",[_("li",[v._v("创建之前，此时还没有 data 和 Method。")])])]),v._v(" "),_("li",[_("p",[v._v("Created")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("创建完成，此时 data 和 Method 可以使用了。")])]),v._v(" "),_("li",[_("p",[v._v("在 Created 之后 beforeMount 之前如果没有el选项的话那么此时生命周期结束，停止编译，如果有则继续。")])])])]),v._v(" "),_("li",[_("p",[v._v("beforeMount")]),v._v(" "),_("ul",[_("li",[v._v("在渲染之前。")])])]),v._v(" "),_("li",[_("p",[v._v("mounted")]),v._v(" "),_("ul",[_("li",[v._v("页面已经渲染完成，并且"),_("code",[v._v("vm")]),v._v("实例中已经添加完"),_("code",[v._v("$el")]),v._v("了，已经替换掉那些 DOM 元素了(双括号中的变量)，这个时候可以操作 DOM 了(但是是获取不了元素的高度等属性的，如果想要获取，需要使用"),_("code",[v._v("nextTick()")]),v._v(")。")])])]),v._v(" "),_("li",[_("p",[v._v("beforeUpdate")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("data")]),v._v("改变后，对应的组件重新渲染之前。")])])]),v._v(" "),_("li",[_("p",[v._v("updated")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("data")]),v._v("改变后，对应的组件重新渲染完成。")])])]),v._v(" "),_("li",[_("p",[v._v("beforeDestory")]),v._v(" "),_("ul",[_("li",[v._v("在实例销毁之前，此时实例仍然可以使用。")])])]),v._v(" "),_("li",[_("p",[v._v("destoryed")]),v._v(" "),_("ul",[_("li",[v._v("实例销毁后。")])])])]),v._v(" "),_("h2",{attrs:{id:"_4-vue-中父子组件的生命周期-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue-中父子组件的生命周期-中级"}},[v._v("#")]),v._v(" 4. vue 中父子组件的生命周期（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("父子组件的生命周期是一个嵌套的过程。")])]),v._v(" "),_("li",[_("p",[v._v("渲染的过程。")]),v._v(" "),_("ul",[_("li",[v._v("父"),_("code",[v._v("beforeCreate")]),v._v("->父"),_("code",[v._v("created")]),v._v("->父"),_("code",[v._v("beforeMount")]),v._v("->子"),_("code",[v._v("beforeCreate")]),v._v("->子"),_("code",[v._v("created")]),v._v("->子"),_("code",[v._v("beforeMount")]),v._v("->子"),_("code",[v._v("mounted")]),v._v("->父"),_("code",[v._v("mounted")])])])]),v._v(" "),_("li",[_("p",[v._v("子组件更新过程。")]),v._v(" "),_("ul",[_("li",[v._v("父"),_("code",[v._v("beforeUpdate")]),v._v("->子"),_("code",[v._v("beforeUpdate")]),v._v("->子"),_("code",[v._v("updated")]),v._v("->父"),_("code",[v._v("updated")])])])]),v._v(" "),_("li",[_("p",[v._v("父组件更新过程。")]),v._v(" "),_("ul",[_("li",[v._v("父"),_("code",[v._v("beforeUpdate")]),v._v("->父"),_("code",[v._v("updated")])])])]),v._v(" "),_("li",[_("p",[v._v("销毁过程。")]),v._v(" "),_("ul",[_("li",[v._v("父"),_("code",[v._v("beforeDestroy")]),v._v("->子"),_("code",[v._v("beforeDestroy")]),v._v("->子"),_("code",[v._v("destroyed")]),v._v("->父"),_("code",[v._v("destroyed")])])])])]),v._v(" "),_("h2",{attrs:{id:"_5-vue-中的nexttick-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue-中的nexttick-中级"}},[v._v("#")]),v._v(" 5. Vue 中的"),_("code",[v._v("nextTick")]),v._v("（中级）")]),v._v(" "),_("ul",[_("li",[v._v("nextTick\n"),_("ul",[_("li",[v._v("解释。\n"),_("ul",[_("li",[_("code",[v._v("nextTick")]),v._v("：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。")])])]),v._v(" "),_("li",[v._v("应用。\n"),_("ul",[_("li",[v._v("想要在 Vue 生命周期函数中的"),_("code",[v._v("created()")]),v._v("操作 DOM 可以使用"),_("code",[v._v("Vue.nextTick()")]),v._v("回调函数。")]),v._v(" "),_("li",[v._v("在数据改变后要执行的操作，而这个操作需要等数据改变后而改变 DOM 结构的时候才进行操作，需要用到"),_("code",[v._v("nextTick")]),v._v("。")])])])])])]),v._v(" "),_("h2",{attrs:{id:"_6-computed-和-watch-的区别-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-computed-和-watch-的区别-中级"}},[v._v("#")]),v._v(" 6. computed 和 watch 的区别（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("computed")]),v._v(" "),_("ul",[_("li",[v._v("计算属性，依赖其他属性，当其他属性改变的时候下一次获取computed值时也会改变，"),_("code",[v._v("computed")]),v._v("的值会有缓存。")])])]),v._v(" "),_("li",[_("p",[v._v("watch")]),v._v(" "),_("ul",[_("li",[v._v("类似于数据改变后的回调。")]),v._v(" "),_("li",[v._v("如果想深度监听的话，后面加一个"),_("code",[v._v("deep:true")]),v._v("。")]),v._v(" "),_("li",[v._v("如果想监听完立马运行的话，后面加一个"),_("code",[v._v("immediate:true")]),v._v("。")])])])]),v._v(" "),_("h2",{attrs:{id:"_7-vue-优化方式-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue-优化方式-中级"}},[v._v("#")]),v._v(" 7. Vue 优化方式（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("v-if 和v-show。")])]),v._v(" "),_("li",[_("p",[v._v("使用"),_("code",[v._v("Object.freeze()")]),v._v("方式冻结data中的属性，从而阻止数据劫持。")])]),v._v(" "),_("li",[_("p",[v._v("组件销毁的时候会断开所有与实例联系，但是除了"),_("code",[v._v("addEventListener")]),v._v("，所以当一个组件销毁的时候需要手动去"),_("code",[v._v("removeEventListener")])])]),v._v(" "),_("li",[_("p",[v._v("图片懒加载。")])]),v._v(" "),_("li",[_("p",[v._v("路由懒加载。")])]),v._v(" "),_("li",[_("p",[v._v("为减少重新渲染和创建 dom 节点的时间，采用虚拟 dom。")])])]),v._v(" "),_("h2",{attrs:{id:"_8-vue-router-的模式-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue-router-的模式-中级"}},[v._v("#")]),v._v(" 8. Vue-router 的模式（中级）")]),v._v(" "),_("ul",[_("li",[v._v("hash模式。\n"),_("ul",[_("li",[v._v("利用 onhashchange 事件实现前端路由，利用 url 中的 hash 来模拟一个 hash，以保证 url 改变时，页面不会重新加载。")])])]),v._v(" "),_("li",[v._v("history模式。\n"),_("ul",[_("li",[v._v("利用 pushstate 和 replacestate 来将 url 替换但不刷新，但是有一个致命点就是，一旦刷新的话，就会可能404，因为没有当前的真正路径，要想解决这一问题需要后端配合，将不存在的路径重定向到入口文件。")])])])]),v._v(" "),_("h2",{attrs:{id:"_9-mvc-与-mvvm-有什么区别-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-mvc-与-mvvm-有什么区别-中级"}},[v._v("#")]),v._v(" 9. MVC 与 MVVM 有什么区别（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("MVC")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Model(模型)是应用程序中用于处理应用程序"),_("strong",[v._v("数据逻辑的部分")]),v._v("。通常模型对象负责在数据库中"),_("strong",[v._v("存取数据")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("View(视图)是应用程序中处理"),_("strong",[v._v("数据显示的部分")]),v._v("。通常视图是依据模型数据创建的。")])]),v._v(" "),_("li",[_("p",[v._v("Controller(控制器)是应用程序中")]),v._v(" "),_("p",[v._v("处理用户交互的部分")]),v._v(" "),_("ul",[_("li",[v._v("通常控制器负责"),_("strong",[v._v("从视图读取数据，控制用户输入，并向模型发送数据")]),v._v("。")])])])])])]),v._v(" "),_("h2",{attrs:{id:"_10-diff-算法-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-diff-算法-中级"}},[v._v("#")]),v._v(" 10. diff 算法（中级）")]),v._v(" "),_("p",[v._v("diff 算法是指对新旧虚拟节点进行对比，并返回一个 patch 对象，用来存储两个节点不同的地方，最后利用 patch 记录的消息局部更新 DOM。")]),v._v(" "),_("h2",{attrs:{id:"_11-虚拟-dom-的优缺点-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-虚拟-dom-的优缺点-中级"}},[v._v("#")]),v._v(" 11. 虚拟 DOM 的优缺点（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("缺点")]),v._v(" "),_("ul",[_("li",[v._v("首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。")])])]),v._v(" "),_("li",[_("p",[v._v("优点")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("减少了 DOM 操作，减少了回流与重绘。")])]),v._v(" "),_("li",[_("p",[v._v("保证性能的下限，虽说性能不是最佳，但是它具备局部更新的能力，所以大部分时候还是比正常的 DOM 性能高很多的。")])])])])]),v._v(" "),_("h2",{attrs:{id:"_12-vue-的-key-的作用-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-vue-的-key-的作用-中级"}},[v._v("#")]),v._v(" 12. Vue 的 Key 的作用（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("key")]),v._v(" "),_("ul",[_("li",[v._v("key 主要用在虚拟 Dom 算法中，每个虚拟节点 VNode 有一个唯一标识 Key，通过对比新旧节点的 key 来判断节点是否改变，用 key 就可以大大提高渲染效率，这个 key 类似于缓存中的 etag。")])])])]),v._v(" "),_("h2",{attrs:{id:"_13-vue-组件之间的通信方式-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-vue-组件之间的通信方式-中级"}},[v._v("#")]),v._v(" 13. Vue 组件之间的通信方式（中级）")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("子组件设置props + 父组件设置"),_("code",[v._v("v-bind:")]),v._v("/"),_("code",[v._v(":")]),v._v("。")]),v._v(" "),_("ul",[_("li",[v._v("父传子")])])]),v._v(" "),_("li",[_("p",[v._v("子组件的$emit + 父组件设置"),_("code",[v._v("v-on")]),v._v("/"),_("code",[v._v("@")]),v._v("。")]),v._v(" "),_("ul",[_("li",[v._v("子传父")])])]),v._v(" "),_("li",[_("p",[v._v("任意组件通信，新建一个空的全局Vue对象，利用 e m i t 发 送 ， emit发送， emit发送，on接收。")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("传说中的$bus")])]),v._v(" "),_("li",[_("p",[v._v("任意组件")]),v._v(" "),_("div",{staticClass:"language-javascript extra-class"},[_("pre",{pre:!0,attrs:{class:"language-javascript"}},[_("code",[_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Vue")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("prototype"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("Event"),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("Vue")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n\t\nEvent"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("$emit")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("事件名"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("数据"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\nEvent"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("$on")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("事件名"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),_("span",{pre:!0,attrs:{class:"token parameter"}},[v._v("data")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=>")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])])])])])]),v._v(" "),_("li",[_("p",[v._v("Vuex")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("里面的属性有：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("state")]),v._v(" "),_("ul",[_("li",[v._v("存储数据的。")]),v._v(" "),_("li",[v._v("获取数据最好推荐使用 getters。")]),v._v(" "),_("li",[v._v("硬要使用的话可以用 MapState， 先引用，放在 compute 中"),_("code",[v._v("...mapState(['方法名','方法名'])")]),v._v("。")])])]),v._v(" "),_("li",[_("p",[v._v("getters")]),v._v(" "),_("ul",[_("li",[v._v("获取数据的。")]),v._v(" "),_("li",[v._v("this.$store.getters.xxx。")]),v._v(" "),_("li",[v._v("也可使用mapGetters 先引用，放在compute中，"),_("code",[v._v("...mapGetters(['方法名','方法名'])")]),v._v("。")])])]),v._v(" "),_("li",[_("p",[v._v("mutations")]),v._v(" "),_("ul",[_("li",[v._v("同步操作数据的。")]),v._v(" "),_("li",[v._v("this.$store.commit(“方法名”,数据)。")]),v._v(" "),_("li",[v._v("也可使用mapMutations ，使用方法和以上一样。")])])]),v._v(" "),_("li",[_("p",[v._v("actions")]),v._v(" "),_("ul",[_("li",[v._v("异步操作数据的。")]),v._v(" "),_("li",[v._v("this.$store.dispatch(“方法名”,数据)。")]),v._v(" "),_("li",[v._v("也可使用mapActions ，使用方法和以上一样。")])])]),v._v(" "),_("li",[_("p",[v._v("modules")]),v._v(" "),_("ul",[_("li",[v._v("板块，里面可以放多个vuex。")])])])])])])]),v._v(" "),_("li",[_("p",[v._v("父组件通过"),_("code",[v._v("v-bind:")]),v._v("/"),_("code",[v._v(":")]),v._v("传值，子组件通过"),_("code",[v._v("this.$attrs")]),v._v("获取。")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("父传子")])]),v._v(" "),_("li",[_("p",[v._v("当子组件没有设置props的时候可以使用")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("this.$attrs")]),v._v("获取到的是一个对象(所有父组件传过来的集合)")])])])]),v._v(" "),_("li",[_("p",[v._v("祖先组件使用provide提供数据，子孙组件通过inject注入数据。")])]),v._v(" "),_("li",[_("p",[v._v("p a r e n t / parent/ parent/children。")])]),v._v(" "),_("li",[_("p",[v._v("refs—$ref。")])]),v._v(" "),_("li",[_("p",[v._v("还有一个，这个网上没有，我自己认为的，我觉得挺对的，slot-scope，本身父组件使用slot插槽是无法获取子组件的数据的，但是使用了 slot-scope 就可以获取到子组件的数据(拥有了子组件的作用域)。")])])]),v._v(" "),_("h2",{attrs:{id:"_14-vue-router有哪几种钩子函数-中级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14-vue-router有哪几种钩子函数-中级"}},[v._v("#")]),v._v(" 14. Vue router有哪几种钩子函数？（中级）")]),v._v(" "),_("ul",[_("li",[v._v("beforeEach\n"),_("ul",[_("li",[v._v("参数有：\n"),_("ul",[_("li",[v._v("to(Route路由对象)")]),v._v(" "),_("li",[v._v("from(Route路由对象)")]),v._v(" "),_("li",[v._v("next(function函数) 一定要调用才能进行下一步")])])])])]),v._v(" "),_("li",[v._v("afterEach")]),v._v(" "),_("li",[v._v("beforeRouterLeave")])]),v._v(" "),_("h2",{attrs:{id:"_15-vue3-的设计目标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_15-vue3-的设计目标"}},[v._v("#")]),v._v(" 15. Vue3 的设计目标")]),v._v(" "),_("p",[v._v("结论：大体上可以概括为：更小、更快、更友好。")]),v._v(" "),_("p",[v._v("在 vue3 之前，我们大致会面临以下几个问题：")]),v._v(" "),_("p",[v._v("1、随着功能的增长，复杂组件的代码变得越来越难以维护")]),v._v(" "),_("p",[v._v("2、缺少一种比较干净的在多个组件之间提取和复用逻辑的机制")]),v._v(" "),_("p",[v._v("3、类型推断不是很友好")]),v._v(" "),_("p",[v._v("4、"),_("strong",[v._v("bundle")]),v._v("的时间太久")]),v._v(" "),_("blockquote",[_("p",[v._v("在 Vue3 中，加入"),_("code",[v._v("TypeScript")]),v._v("支持，提升了 API 设计的一致性、提高了自身的可维护性、开放更多底层功能。")])]),v._v(" "),_("p",[_("strong",[v._v("分析")]),v._v("：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("更小：")]),v._v(" "),_("p",[v._v("1、Vue3 移除一些不常用的 API.")]),v._v(" "),_("p",[v._v("2、引入 tree-shaking，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了。")])]),v._v(" "),_("li",[_("p",[v._v("更快：")]),v._v(" "),_("p",[v._v("主要体现在编译方面：")]),v._v(" "),_("p",[v._v("1、diff 算法优化")]),v._v(" "),_("p",[v._v("2、静态提升")]),v._v(" "),_("p",[v._v("3、事件监听缓存")]),v._v(" "),_("p",[v._v("4、SSR 优化")])]),v._v(" "),_("li",[_("p",[v._v("更友好")]),v._v(" "),_("p",[v._v("1、"),_("strong",[v._v("vue3")]),v._v(" 在兼顾 "),_("strong",[v._v("vue2")]),v._v(" 的"),_("code",[v._v("options API")]),v._v("的同时还推出了"),_("code",[v._v("composition API")]),v._v("，大大增加了代码的逻辑组织和代码复用能力。")]),v._v(" "),_("p",[v._v("2、基于"),_("code",[v._v("TypeScript")]),v._v("编写，可以享受自动的类型定义提示。")])])]),v._v(" "),_("h2",{attrs:{id:"_16-vue3-做了哪些优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_16-vue3-做了哪些优化"}},[v._v("#")]),v._v(" 16. Vue3 做了哪些优化")]),v._v(" "),_("p",[v._v("大体上可分为三个方面：源码、性能、语法 API.")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("源码：")]),v._v(" "),_("p",[v._v("1、源码管理")]),v._v(" "),_("p",[v._v("通过"),_("code",[v._v("monorepo")]),v._v("方式对源码进行维护，根据功能，将不同的模块进行拆分，放到对应的"),_("code",[v._v("package")]),v._v("目录下面的子目录中。这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。")]),v._v(" "),_("p",[v._v("2、TypeScript")]),v._v(" "),_("p",[v._v("Vue3 是基于"),_("code",[v._v("TypeScript")]),v._v("编写的，提供了更好的类型检查，能支持复杂的类型推导。")])]),v._v(" "),_("li",[_("p",[v._v("性能：")]),v._v(" "),_("p",[v._v("主要通过"),_("strong",[v._v("体积优化")]),v._v("、"),_("strong",[v._v("编译优化")]),v._v("、"),_("strong",[v._v("数据劫持优化")]),v._v("。")]),v._v(" "),_("p",[v._v("在 vue2 中，数据劫持是通过 Object.defineProperty，这个 API 有一些缺陷，并不能检测对象属性的添加和删除。在面对嵌套层级比较深的情况下，存在性能问题。")]),v._v(" "),_("p",[v._v("相比之下，vue3 是通过 proxy 监听整个对象，那么对于删除还是监听当然也能监听到。")]),v._v(" "),_("p",[v._v("同时 Proxy 并不能监听到内部深层次的对象变化，而 Vue3 的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归。")])]),v._v(" "),_("li",[_("p",[v._v("语法 API:")]),v._v(" "),_("p",[v._v("Vue3 中提供了"),_("code",[v._v("Composition API")]),v._v("，优化逻辑组织和逻辑复用。")]),v._v(" "),_("p",[v._v("在 vue2 中，我们是通过"),_("strong",[v._v("mixin")]),v._v("实现功能混合，如果多个 mixin 混合，会存在两个非常明显的问题："),_("strong",[v._v("命名冲突")]),v._v("和"),_("strong",[v._v("数据来源不清晰")]),v._v("。")]),v._v(" "),_("p",[v._v("而通过"),_("code",[v._v("Composition API")]),v._v("这种形式，可以将一些复用的代码抽离出来作为一个函数，只要的使用的地方直接进行调用即可。")])])]),v._v(" "),_("h2",{attrs:{id:"_17-vue3-性能提升主要是通过哪几方面体现的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_17-vue3-性能提升主要是通过哪几方面体现的"}},[v._v("#")]),v._v(" 17. Vue3 性能提升主要是通过哪几方面体现的")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("编译阶段")]),v._v(" "),_("p",[v._v("1、diff 算法优化")]),v._v(" "),_("p",[v._v("vue3 在 diff 算法中相比 vue2 增加了"),_("strong",[v._v("静态标记")])]),v._v(" "),_("p",[v._v("关于这个静态标记，其作用是在会发生变化的地方添加一个"),_("strong",[v._v("flag 标记")]),v._v("，下次发生变化的时候直接找该地方进行比较。")]),v._v(" "),_("p",[v._v("2、静态提升")]),v._v(" "),_("p",[v._v("Vue3 中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用。")]),v._v(" "),_("p",[v._v("这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用。")]),v._v(" "),_("p",[v._v("3、事件监听缓存")]),v._v(" "),_("p",[v._v("默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化，开启了缓存后，将失去"),_("strong",[v._v("静态标记")]),v._v("。也就是说下次 diff 算法的时候"),_("strong",[v._v("直接使用")]),v._v("。")]),v._v(" "),_("p",[v._v("4、SSR 优化")]),v._v(" "),_("p",[v._v("当静态内容大到一定量级时候，会用"),_("code",[v._v("createStaticVNode")]),v._v("方法在客户端去生成一个"),_("strong",[v._v("static node")]),v._v("，这些静态 node，会被直接 innerHtml，就不需要创建对象，然后根据对象渲染。")])]),v._v(" "),_("li",[_("p",[v._v("源码体积")]),v._v(" "),_("p",[v._v("相比 Vue2，Vue3 整体体积变小了，除了移除一些不常用的 API，再重要的是"),_("code",[v._v("Tree shanking")]),v._v(".")]),v._v(" "),_("p",[v._v("任何一个函数，如 ref、reavtived、computed 等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小。")])]),v._v(" "),_("li",[_("p",[v._v("响应式系统")]),v._v(" "),_("p",[v._v("vue2 中采用 "),_("code",[v._v("defineProperty")]),v._v(" 来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加 getter 和 setter，实现响应式。")]),v._v(" "),_("p",[v._v("vue3 采用 "),_("code",[v._v("proxy")]),v._v(" 重写了响应式系统，因为 proxy 可以对整个对象进行监听，所以不需要深度遍历。")])])]),v._v(" "),_("h2",{attrs:{id:"_18-vue3-所采用的-composition-api-与-vue2-使用的-options-api-有什么不同"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_18-vue3-所采用的-composition-api-与-vue2-使用的-options-api-有什么不同"}},[v._v("#")]),v._v(" 18. Vue3 所采用的 Composition Api 与 Vue2 使用的 Options Api 有什么不同？")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("Options API")])]),v._v(" "),_("p",[v._v("Options API，即大家常说的选项 API，即以 vue 为后缀的文件，通过定义 methods，computed，watch，data 等属性与方法，共同处理页面逻辑。")]),v._v(" "),_("p",[v._v("当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("Composition Api")])]),v._v(" "),_("p",[v._v("在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）。")]),v._v(" "),_("p",[v._v("即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("对比")])]),v._v(" "),_("p",[v._v("1、逻辑组织")]),v._v(" "),_("p",[v._v("Options API 中，假设一个组件是一个大型组件，其内部有很多处理逻辑关注点。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地跳转相关代码的选项块。")]),v._v(" "),_("p",[v._v("Composition API 中，逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去。")]),v._v(" "),_("p",[v._v("2、逻辑复用")]),v._v(" "),_("p",[v._v("在 Vue2 中，我们是用过 mixin 去复用相同的逻辑，使用单个 mixin 似乎问题不大，但是当我们一个组件混入大量不同的 mixins 的时候，会存在两个非常明显的问题：命名冲突、数据来源不清晰。")]),v._v(" "),_("p",[v._v("Composition API 中，可将逻辑抽离出去，整个数据来源清晰，即使去编写更多的 hook 函数，也不会出现命名冲突的问题。")])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("总结")])]),v._v(" "),_("p",[v._v("1、在逻辑组织和逻辑复用方面，"),_("code",[v._v("Composition API")]),v._v(" 是优于 "),_("code",[v._v("Options API")]),v._v("。")]),v._v(" "),_("p",[v._v("2、因为 "),_("code",[v._v("Composition API")]),v._v(" 几乎是函数，会有更好的类型推断。")]),v._v(" "),_("p",[v._v("3、"),_("code",[v._v("Composition API")]),v._v(" 对 "),_("code",[v._v("tree-shaking")]),v._v(" 友好，代码也更容易压缩。")]),v._v(" "),_("p",[v._v("4、"),_("code",[v._v("Composition API")]),v._v(" 中见不到 "),_("code",[v._v("this")]),v._v(" 的使用，减少了 this 指向不明的情况。")]),v._v(" "),_("p",[v._v("5、如果是小型组件，可以继续使用 "),_("code",[v._v("Options API")]),v._v("，也是十分友好的。")])])])])}),[],!1,null,null,null);_.default=a.exports}}]);