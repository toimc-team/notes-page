(window.webpackJsonp=window.webpackJsonp||[]).push([[191],{1212:function(t,s,a){"use strict";a.r(s);var r=a(11),e=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"fiber及其工作原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fiber及其工作原理"}},[t._v("#")]),t._v(" Fiber及其工作原理")]),t._v(" "),s("h2",{attrs:{id:"fiber-架构简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fiber-架构简介"}},[t._v("#")]),t._v(" Fiber 架构简介")]),t._v(" "),s("p",[t._v("Fiber 是 React 16 中引入的新协调引擎，它是对 React 核心算法的完全重写，旨在解决 React 15 和之前版本中的性能问题。")]),t._v(" "),s("p",[t._v("Fiber 架构的核心目标：")]),t._v(" "),s("ul",[s("li",[t._v("能够将渲染工作分片")]),t._v(" "),s("li",[t._v("能够为不同类型的更新分配优先级")]),t._v(" "),s("li",[t._v("能够暂停、中止或重用渲染工作")]),t._v(" "),s("li",[t._v("能够在父子组件之间更灵活地传递信息")])]),t._v(" "),s("h2",{attrs:{id:"为什么需要-fiber"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要-fiber"}},[t._v("#")]),t._v(" 为什么需要 Fiber")]),t._v(" "),s("p",[t._v('在 React 15 及之前的版本中，React 使用的是递归的方式进行协调过程（Reconciliation），这种方式被称为"栈协调器"（Stack Reconciler）。当组件树很大时，递归更新可能会阻塞主线程，导致一些问题：')]),t._v(" "),s("ul",[s("li",[t._v("无法中断渲染，必须一次性完成所有工作")]),t._v(" "),s("li",[t._v("动画和用户输入等高优先级工作无法及时响应，导致页面卡顿")]),t._v(" "),s("li",[t._v("如果渲染时间过长，可能导致帧率下降，影响用户体验")])]),t._v(" "),s("h2",{attrs:{id:"fiber-的工作原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fiber-的工作原理"}},[t._v("#")]),t._v(" Fiber 的工作原理")]),t._v(" "),s("h3",{attrs:{id:"fiber-数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fiber-数据结构"}},[t._v("#")]),t._v(" Fiber 数据结构")]),t._v(" "),s("p",[t._v("Fiber 是一种链表结构，每个 Fiber 节点对应一个 React 元素，包含如下重要信息：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 标记 Fiber 类型（函数组件/类组件/文本/宿主组件等）")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("tag")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" WorkTag"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向父、子、兄弟节点的指针，形成树结构")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 父节点")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("child")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 第一个子节点")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("sibling")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 下一个兄弟节点")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 节点状态和更新信息")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("pendingProps")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 新的待处理属性")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("memoizedProps")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 已处理的属性")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("memoizedState")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 组件状态")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("updateQueue")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" UpdateQueue"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("any"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 更新队列")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 与渲染输出相关")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("stateNode")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 宿主组件实例（如 DOM 节点）")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 工作标记（用于调度）")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("flags")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Flags"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向备用 Fiber 的指针（双缓存）")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("alternate")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Fiber "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"双缓存机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#双缓存机制"}},[t._v("#")]),t._v(" 双缓存机制")]),t._v(" "),s("p",[t._v("Fiber 架构采用双缓存（Double Buffering）技术：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("current Fiber 树")]),t._v("：当前已经渲染到屏幕上的树")]),t._v(" "),s("li",[s("strong",[t._v("workInProgress Fiber 树")]),t._v("：正在构建的新树")])]),t._v(" "),s("p",[t._v("这种机制使 React 能够在后台构建完整的 UI 树，而不影响当前显示的内容。只有当新树完全准备好时，React 才会一次性地切换到这个新树，从而减少中间状态导致的视觉不一致。")]),t._v(" "),s("h3",{attrs:{id:"工作循环与时间切片"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#工作循环与时间切片"}},[t._v("#")]),t._v(" 工作循环与时间切片")]),t._v(" "),s("p",[t._v("Fiber 架构的核心是其工作循环（work loop），它可以被中断：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("workLoop")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("deadline")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 是否应该让出控制权")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" shouldYield "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 有工作要做且不需要让出控制权")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nextUnitOfWork "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("shouldYield"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 执行一个工作单元并返回下一个工作单元")]),t._v("\n    nextUnitOfWork "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("performUnitOfWork")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nextUnitOfWork"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 检查是否还有剩余时间")]),t._v("\n    shouldYield "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" deadline"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("timeRemaining")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  \n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果没有下一个工作单元但有待处理的工作，请求下一次调度")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("nextUnitOfWork "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" workInProgressRoot"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("commitRoot")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  \n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 安排下一次工作")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("requestIdleCallback")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("workLoop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("这种实现使 React 能够：")]),t._v(" "),s("ul",[s("li",[t._v("在浏览器空闲时间执行渲染工作")]),t._v(" "),s("li",[t._v("在必要时暂停渲染，让出主线程以处理高优先级的事件")]),t._v(" "),s("li",[t._v("为不同类型的更新分配不同的优先级")])]),t._v(" "),s("h3",{attrs:{id:"fiber-执行的两个阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fiber-执行的两个阶段"}},[t._v("#")]),t._v(" Fiber 执行的两个阶段")]),t._v(" "),s("p",[t._v("Fiber 渲染过程分为两个阶段：")]),t._v(" "),s("ol",[s("li",[s("p",[s("strong",[t._v("Render 阶段")]),t._v("（可中断）：")]),t._v(" "),s("ul",[s("li",[t._v("构建 Fiber 树")]),t._v(" "),s("li",[t._v("计算变更")]),t._v(" "),s("li",[t._v("可以被中断、重启、放弃")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("Commit 阶段")]),t._v("（不可中断）：")]),t._v(" "),s("ul",[s("li",[t._v("将变更应用到 DOM")]),t._v(" "),s("li",[t._v("调用生命周期方法")]),t._v(" "),s("li",[t._v("一旦开始就必须同步完成")])])])]),t._v(" "),s("h2",{attrs:{id:"fiber-带来的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fiber-带来的优势"}},[t._v("#")]),t._v(" Fiber 带来的优势")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("提高应用响应性")]),t._v("：通过时间切片，避免长时间阻塞主线程")]),t._v(" "),s("li",[s("strong",[t._v("优先级调度")]),t._v("：可以根据任务的紧急程度分配优先级，优先处理用户交互")]),t._v(" "),s("li",[s("strong",[t._v("更细粒度的更新")]),t._v("：能够暂停、中止或重用渲染工作")]),t._v(" "),s("li",[s("strong",[t._v("并发模式的基础")]),t._v("：为 React 18 中的并发特性奠定了基础")]),t._v(" "),s("li",[s("strong",[t._v("更好的错误处理")]),t._v("：可以在不影响整个应用的情况下处理错误")])]),t._v(" "),s("h2",{attrs:{id:"与-react-18-并发特性的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#与-react-18-并发特性的关系"}},[t._v("#")]),t._v(" 与 React 18 并发特性的关系")]),t._v(" "),s("p",[t._v("Fiber 架构为 React 18 中的并发渲染提供了基础设施。在 React 18 中，新引入的特性如 "),s("code",[t._v("useTransition")]),t._v("、"),s("code",[t._v("useDeferredValue")]),t._v(" 和自动批处理都是建立在 Fiber 架构之上的。")]),t._v(" "),s("p",[t._v('通过 Fiber 架构，React 能够实现真正的"并发渲染"，即同时准备多个版本的 UI，并根据优先级决定先渲染哪个，从而提供更流畅的用户体验。')])])}),[],!1,null,null,null);s.default=e.exports}}]);