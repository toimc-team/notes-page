(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{1211:function(t,a,s){"use strict";s.r(a);var e=s(11),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react核心概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react核心概念"}},[t._v("#")]),t._v(" React核心概念")]),t._v(" "),a("h2",{attrs:{id:"概览"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概览"}},[t._v("#")]),t._v(" 概览")]),t._v(" "),a("p",[t._v("大多人应该了解的React是这样的：")]),t._v(" "),a("ul",[a("li",[t._v("JSX")]),t._v(" "),a("li",[t._v("hooks")]),t._v(" "),a("li",[t._v("虚拟DOM")]),t._v(" "),a("li",[t._v("生命周期的方法")]),t._v(" "),a("li",[t._v("...")])]),t._v(" "),a("p",[t._v("核心，简单易用~")]),t._v(" "),a("p",[t._v("有一些核心的概念：")]),t._v(" "),a("ul",[a("li",[t._v("Reconciliation 协调")]),t._v(" "),a("li",[t._v("Rendering 渲染")]),t._v(" "),a("li",[t._v("Virual DOM & diffing algorithm 虚拟DOM与Diff算法")])]),t._v(" "),a("h2",{attrs:{id:"三个易混概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三个易混概念"}},[t._v("#")]),t._v(" 三个易混概念")]),t._v(" "),a("h3",{attrs:{id:"react-element"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-element"}},[t._v("#")]),t._v(" React Element")]),t._v(" "),a("p",[t._v("React中的元素：")]),t._v(" "),a("p",[a("img",{attrs:{src:s(988),alt:"image-20220225152932315"}})]),t._v(" "),a("p",[t._v("写JSX总是需要导入react的原因：")]),t._v(" "),a("ul",[a("li",[t._v("JSX被转换成React.createElement函数")]),t._v(" "),a("li",[t._v("所有的函数组合成了如上的Object")])]),t._v(" "),a("p",[t._v("这样，可以通过写HTML的形式来写JS，一方面，可以提高编写页面的速度，又可以依托JS来高效处理页面的DOM：")]),t._v(" "),a("p",[a("img",{attrs:{src:s(989),alt:"image-20220225153709167"}})]),t._v(" "),a("h3",{attrs:{id:"react-component"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-component"}},[t._v("#")]),t._v(" React Component")]),t._v(" "),a("p",[t._v("React中的组件有两种：函数式组件、类组件（以前还有有状态组件、无状态组件）。")]),t._v(" "),a("ul",[a("li",[t._v("如果是一个函数，直接调用并带上Props")]),t._v(" "),a("li",[t._v("如果是一个类，则创建实例后调用render")])]),t._v(" "),a("p",[t._v("React Element可以等价于DOM节点也可以用来代表组件实例。")]),t._v(" "),a("h3",{attrs:{id:"组件实例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件实例"}},[t._v("#")]),t._v(" 组件实例")]),t._v(" "),a("ul",[a("li",[t._v("组件实例提供this变量，追踪组件，调用组件属性&方法")]),t._v(" "),a("li",[t._v("所有的实例都会有生命周期方法或者有组件状态")])]),t._v(" "),a("p",[t._v("但是，聪明的程序员也想在函数式组件中使用生命周期的方法，hooks由此诞生：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 函数式")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("state"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" setState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("useState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("useEffect")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// todo")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 类组件")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentDidMount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentWillUnmount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"reconciliation协调"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reconciliation协调"}},[t._v("#")]),t._v(" Reconciliation协调")]),t._v(" "),a("p",[t._v("作用：负载找出变化的组件")]),t._v(" "),a("h3",{attrs:{id:"虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" "),a("strong",[t._v("虚拟DOM")])]),t._v(" "),a("p",[t._v("React会创建组件树（JS对象），因为JS执行速度非常快，这个过程会在Render调用时触发。——这就是虚拟DOM！")]),t._v(" "),a("h3",{attrs:{id:"diff算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff算法"}},[t._v("#")]),t._v(" Diff算法")]),t._v(" "),a("p",[t._v("为了提升DOM处理的速度，设计了虚拟DOM的比较算法，Diff算法。")]),t._v(" "),a("p",[t._v("通常情况下，两个DOM树的比较需要O（n3），这样的开销太大。而React的Diff算法，把这个复杂度降到了O（n）。")]),t._v(" "),a("p",[t._v("策略：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("两个不同类型的元素将产生不同的树")])]),t._v(" "),a("li",[a("p",[t._v("对于经常变化的元素，提供key进行标记")]),t._v(" "),a("p",[a("img",{attrs:{src:s(990),alt:"image-20220225160004327"}})]),t._v(" "),a("p",[t._v("React可以清晰的知道，哪个是新增的节点，哪个不需要更新。")])])]),t._v(" "),a("h2",{attrs:{id:"rendering渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rendering渲染"}},[t._v("#")]),t._v(" Rendering渲染")]),t._v(" "),a("p",[t._v("作用：负责将变化的组件渲染到页面上")]),t._v(" "),a("p",[t._v("React中有React DOM、React Native等渲染器。")]),t._v(" "),a("h2",{attrs:{id:"react15-vs-react16"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react15-vs-react16"}},[t._v("#")]),t._v(" React15 vs React16")]),t._v(" "),a("h3",{attrs:{id:"旧reconciler架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#旧reconciler架构"}},[t._v("#")]),t._v(" 旧Reconciler架构")]),t._v(" "),a("ul",[a("li",[t._v("栈是同步的结构 -> 同步会导致阻塞")]),t._v(" "),a("li",[t._v("工作时，如同栈（先进后出）")]),t._v(" "),a("li",[t._v("只能等栈空了之后才能进行接下来的工作->卡的原因")])])])}),[],!1,null,null,null);a.default=n.exports},988:function(t,a,s){t.exports=s.p+"assets/img/image-20220225152932315.14d6e204.png"},989:function(t,a,s){t.exports=s.p+"assets/img/image-20220225153709167.928ba748.png"},990:function(t,a,s){t.exports=s.p+"assets/img/image-20220225160004327.f9fea1af.png"}}]);